<!DOCTYPE html>
<html lang="lt">
<head>
  <meta charset="UTF-8" />
  <title>Seimo narių balsavimo statistika</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 20px;
      font-size: 1.05rem;
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 0.3rem;
    }

    .subtitle {
      font-size: 1rem;
      color: #555;
      margin-bottom: 0.6rem;
    }

    .source-note {
      margin: 6px 0 16px 0;
      padding: 8px 12px;
      border-left: 4px solid #555;
      background: #f9f9f9;
      font-size: 0.98rem;
      line-height: 1.4;
    }

    .source-note b {
      font-weight: 700;
    }

    label {
      font-weight: 600;
    }

    select {
      min-width: 260px;
      padding: 6px 10px;
      font-size: 1rem;
      margin: 6px 0 10px 0;
    }

    .filters-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
      margin-bottom: 6px;
    }

    .filters-row > div {
      display: flex;
      flex-direction: column;
    }

    .status {
      margin-top: 6px;
      margin-bottom: 8px;
      font-size: 1rem;
      color: #555;
    }

    .error {
      color: #b00020;
      font-weight: 600;
      margin-top: 10px;
    }

    .table-wrapper {
      max-width: 100%;
      overflow-x: auto;
    }

    .table-container {
      max-height: 75vh;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 900px;
    }

    th, td {
      border-bottom: 1px solid #e0e0e0;
      padding: 4px 8px;
      font-size: 1.0rem;
      line-height: 1.25;
      text-align: right;
    }

    th:first-child,
    td:first-child,
    .name-cell {
      text-align: left;
    }

    th {
      background: #f6f6f6;
      font-weight: 700;
      position: sticky;
      top: 0;
      z-index: 2;
    }

    tr:nth-child(even) td {
      background: #fafafa;
    }

    .number-cell {
      white-space: nowrap;
    }

    .name-cell {
      white-space: nowrap;
      width: 260px;
    }

    .party-cell {
      white-space: nowrap;
      width: 260px;
    }

    .party-badge {
      display: inline-block;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.95rem;
      font-weight: 600;
      color: #fff;
      white-space: nowrap;
    }

    .sortable {
      cursor: pointer;
      user-select: none;
    }

    .sortable::after {
      content: " ⇅";
      font-size: 0.8rem;
      color: #999;
    }

    .sortable.sorted-asc::after {
      content: " ↑";
      color: #555;
    }

    .sortable.sorted-desc::after {
      content: " ↓";
      color: #555;
    }

    @media (max-width: 768px) {
      body {
        margin: 10px;
        font-size: 1rem;
      }
      h1 {
        font-size: 1.4rem;
      }
      .subtitle {
        font-size: 0.95rem;
      }
      table {
        min-width: 750px;
      }
    }
  </style>
</head>
<body>
  <h1>Seimo narių balsavimo statistika</h1>
  <div class="subtitle">
    Metinė statistika: kiek kartų kiekvienas Seimo narys balsavo „Už“, „Prieš“, „Susilaikė“, „Nedalyvavo“, „Registravosi“ ir kt.
  </div>

  <div class="source-note">
    <b>Privaloma šaltinio nuoroda.</b><br />
    Naudojant, cituojant ar dalinantis šioje lentelėje pateikta informacija, būtina aiškiai nurodyti šaltinį:<br />
    <em>„Duomenys paimti iš Seimo nario Vitalijaus Šeršniovo parengto šaltinio.“</em>
  </div>

  <div class="filters-row">
    <div>
      <label for="partyFilter">Filtruoti pagal partiją / frakciją:</label>
      <select id="partyFilter" disabled>
        <option value="ALL">Visos partijos</option>
      </select>
    </div>

    <div>
      <label for="metricFilter">Filtruoti pagal pasirinkimą:</label>
      <select id="metricFilter" disabled>
        <option value="">— Pasirink rodiklį —</option>
        <option value="most_uz">Daugiausiai Už</option>
        <option value="least_uz">Mažiausiai Už</option>
        <option value="most_pries">Daugiausiai Prieš</option>
        <option value="least_pries">Mažiausiai Prieš</option>
        <option value="most_susilaike">Daugiausiai Susilaikė</option>
        <option value="least_susilaike">Mažiausiai Susilaikė</option>
        <option value="most_nedalyvavo">Daugiausiai Nedalyvavo</option>
        <option value="least_nedalyvavo">Mažiausiai Nedalyvavo</option>
        <option value="most_reg">Daugiausiai Registravosi</option>
        <option value="least_reg">Mažiausiai Registravosi</option>
        <option value="most_uz_a">Daugiausiai Papildomi A (Už A)</option>
        <option value="least_uz_a">Mažiausiai Papildomi A (Už A)</option>
        <option value="most_uz_b">Daugiausiai Papildomi B (Už B)</option>
        <option value="least_uz_b">Mažiausiai Papildomi B (Už B)</option>
      </select>
    </div>
  </div>

  <div id="status" class="status">Įkeliami duomenys...</div>
  <div id="error" class="error" style="display:none;"></div>

  <div class="table-wrapper">
    <div class="table-container">
      <table id="statsTable">
        <thead id="tableHead"></thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </div>

  <script>
    // Galimi statistikos failo pavadinimai (palieku kelis variantus – tau tinka tas, kuris yra realiai)
    const STATS_FILE_CANDIDATES = [
      "metu balsavimas1.csv",
      "metu_balsavimas1.csv",
      "metu-balsavimas1.csv",
      "metu balsavimai1.csv",
      "metu_balsavimai1.csv",
      "metu-balsavimai1.csv",
      "metu balsavimas.csv",
      "metu_balsavimas.csv"
    ];
    const PARTIES_FILE = "members_parties.csv";

    const memberParty = {};
    let allRows = [];
    let headers = [];
    let nameColIndex = 0;           // "Seimo nariai" stulpelio indeksas
    let metricHeadersFromCsv = [];  // visi balsavimo skaitiniai stulpeliai
    let allMetricHeaders = [];      // čia = metricHeadersFromCsv

    // Nuorodos į konkrečius stulpelius (pagal pavadinimą)
    let keyNed, keyPries, keyUz, keySus, keyReg, keyUzA, keyUzB;

    let currentPartyFilter = "ALL";
    let currentSort = { key: "name", direction: "asc" };

    const partyFilterSelect = document.getElementById("partyFilter");
    const metricFilterSelect = document.getElementById("metricFilter");
    const statusEl = document.getElementById("status");
    const errorEl = document.getElementById("error");
    const tableHead = document.getElementById("tableHead");
    const tableBody = document.getElementById("tableBody");

    // Tos pačios partijos ir spalvos, kaip kitame tavo įrankyje
    const categoryColors = {
      "Tėvynės sąjunga–LKD": "#43BBAE",
      "Liberalai": "#FDBB38",
      "Demokratai": "#3A5778",
      "Socialdemokratai": "#FA0016",
      "Lietuvos valstiečių, žaliųjų ir KŠS frakcija": "#95D05F",
      "Mišri grupė": "#868A8D",
      "Nemuno aušra": "#9A4418"
    };

    function getPartyCategory(partyName) {
      if (!partyName) return "";
      const p = partyName.toLowerCase();

      if (p.startsWith("mišri grupė")) return "Mišri grupė";
      if (p.includes("nemuno aušra")) return "Nemuno aušra";
      if (p.includes("tėvynės sąjunga") || p.includes("tėvynės sajunga") || p.includes("ts-lkd")) {
        return "Tėvynės sąjunga–LKD";
      }
      if (p.includes("liberalų sąjūdis") || p.includes("liberalai")) {
        return "Liberalai";
      }
      if (p.includes("socialdemokrat")) {
        return "Socialdemokratai";
      }
      if (p.includes("demokratų sąjunga") || p.includes("vardan lietuvos")) {
        return "Demokratai";
      }
      if (p.includes("valstiečių") || p.includes("žaliųjų") || p.includes("žaliuju") || p.includes("kšs")) {
        return "Lietuvos valstiečių, žaliųjų ir KŠS frakcija";
      }
      return partyName.trim();
    }

    function getPartyColor(category) {
      if (!category) return "#9e9e9e";
      return categoryColors[category] || "#9e9e9e";
    }

    async function loadCSV(url) {
      const resp = await fetch(url);
      if (!resp.ok) throw new Error("Nepavyko nuskaityti failo: " + url);
      const text = await resp.text();
      const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
      if (lines.length < 3) throw new Error("Faile " + url + " per mažai eilučių.");
      return { lines };
    }

    async function loadParties() {
      try {
        const resp = await fetch(PARTIES_FILE);
        if (!resp.ok) return;

        const text = await resp.text();
        const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
        if (lines.length < 2) return;

        const headerLine = lines[0];
        const delimiter = headerLine.includes(";") ? ";" : ",";
        const headerArr = headerLine.split(delimiter).map(h => h.trim());
        const idxMember = headerArr.indexOf("member");
        const idxParty = headerArr.indexOf("party");
        if (idxMember === -1 || idxParty === -1) return;

        for (let i = 1; i < lines.length; i++) {
          const line = lines[i];
          const cols = line.split(delimiter);
          if (cols.length <= Math.max(idxMember, idxParty)) continue;
          const m = (cols[idxMember] || "").trim();
          const p = (cols[idxParty] || "").trim();
          if (!m) continue;
          memberParty[m] = p;
        }
      } catch (e) {
        console.warn("Nepavyko nuskaityti members_parties.csv:", e);
      }
    }

    function findHeaderKey(headersList, search) {
      const s = search.toLowerCase();
      return headersList.find(h => h.toLowerCase().includes(s)) || null;
    }

    async function loadStats() {
      let lastError = null;

      for (const fname of STATS_FILE_CANDIDATES) {
        try {
          const { lines } = await loadCSV(fname);

          // 1–2 eilutės – paaiškinimai, 3–ia – tikroji antraštė
          const headerLine = lines[2];
          const delimiter = headerLine.includes(";") ? ";" : ",";
          headers = headerLine.split(delimiter).map(h => h.trim());

          // Randam "Seimo nariai" stulpelį
          nameColIndex = 0;
          for (let i = 0; i < headers.length; i++) {
            const t = headers[i].toLowerCase();
            if (t.includes("seimo nariai")) {
              nameColIndex = i;
              break;
            }
          }

          // Kurie stulpeliai – metrika (skaičiai)?
          metricHeadersFromCsv = headers.filter((h, i) => {
            if (i === nameColIndex) return false;
            if (!h.trim()) return false;
            if (/eil/.test(h.toLowerCase())) return false; // "Eil. Nr." atmetam
            return true;
          });

          // Nuskaitom eilutes
          allRows = [];
          for (let i = 3; i < lines.length; i++) {
            const line = lines[i];
            if (!line.trim()) continue;
            const cols = line.split(delimiter);
            if (cols.length < headers.length) continue;

            const rawName = (cols[nameColIndex] || "").trim();
            if (!rawName) continue;
            const name = rawName; // "Seimo narys" – kaip faile

            const partyName = memberParty[name] || "";
            const partyCategory = getPartyCategory(partyName);

            const metrics = {};
            for (let c = 0; c < headers.length; c++) {
              const header = headers[c];
              if (!metricHeadersFromCsv.includes(header)) continue;
              const raw = (cols[c] || "").trim();
              const num = raw === "" ? 0 : Number(raw.replace(",", "."));
              metrics[header] = Number.isFinite(num) ? num : 0;
            }

            allRows.push({ name, partyName, partyCategory, metrics });
          }

          // Susidėliojam visas metrikas (tik iš failo, be jokių papildomų indeksų)
          allMetricHeaders = metricHeadersFromCsv.slice();

          // Susikabinam nuorodas į pagrindinius stulpelius (rodiklių filtrui)
          keyNed  = findHeaderKey(metricHeadersFromCsv, "nedalyvavo");
          keyPries = findHeaderKey(metricHeadersFromCsv, "prieš") || findHeaderKey(metricHeadersFromCsv, "pries");
          keyUz   = findHeaderKey(metricHeadersFromCsv, "už")   || findHeaderKey(metricHeadersFromCsv, "uz");
          keySus  = findHeaderKey(metricHeadersFromCsv, "susilaik");
          keyReg  = findHeaderKey(metricHeadersFromCsv, "registrav");
          keyUzA  = findHeaderKey(metricHeadersFromCsv, "už a") || findHeaderKey(metricHeadersFromCsv, "uz a");
          keyUzB  = findHeaderKey(metricHeadersFromCsv, "už b") || findHeaderKey(metricHeadersFromCsv, "uz b");

          statusEl.textContent = "Duomenys įkelti iš failo: " + fname;
          return;
        } catch (e) {
          lastError = e;
        }
      }

      throw lastError || new Error("Nepavyko rasti metinės statistikos failo.");
    }

    function buildPartyFilterOptions() {
      const set = new Set();
      allRows.forEach(r => {
        if (r.partyCategory && r.partyCategory.trim()) {
          set.add(r.partyCategory.trim());
        }
      });
      const cats = Array.from(set).sort((a, b) => a.localeCompare(b, "lt"));

      partyFilterSelect.innerHTML = "";
      const allOpt = document.createElement("option");
      allOpt.value = "ALL";
      allOpt.textContent = "Visos partijos";
      partyFilterSelect.appendChild(allOpt);

      cats.forEach(cat => {
        const opt = document.createElement("option");
        opt.value = cat;
        opt.textContent = cat;
        partyFilterSelect.appendChild(opt);
      });

      partyFilterSelect.disabled = false;
      metricFilterSelect.disabled = false;
    }

    function buildTableHead() {
      tableHead.innerHTML = "";
      const tr = document.createElement("tr");

      const thIndex = document.createElement("th");
      thIndex.textContent = "#";
      tr.appendChild(thIndex);

      const thName = document.createElement("th");
      thName.textContent = "Seimo narys";
      thName.classList.add("sortable");
      thName.dataset.sortKey = "name";
      tr.appendChild(thName);

      const thParty = document.createElement("th");
      thParty.textContent = "Partija / frakcija";
      thParty.classList.add("sortable");
      thParty.dataset.sortKey = "party";
      tr.appendChild(thParty);

      allMetricHeaders.forEach(header => {
        const th = document.createElement("th");
        th.textContent = header;
        th.classList.add("sortable");
        th.dataset.sortKey = header;
        tr.appendChild(th);
      });

      tableHead.appendChild(tr);

      document.querySelectorAll("th.sortable").forEach(th => {
        th.addEventListener("click", () => {
          const key = th.dataset.sortKey;
          if (!key) return;
          if (currentSort.key === key) {
            currentSort.direction = currentSort.direction === "asc" ? "desc" : "asc";
          } else {
            // Tekstui – asc, skaičiams – desc
            if (key === "name" || key === "party") {
              currentSort = { key, direction: "asc" };
            } else {
              currentSort = { key, direction: "desc" };
            }
          }
          metricFilterSelect.value = ""; // nuimame specialų rodiklio filtrą
          renderTable();
        });
      });
    }

    function renderTable() {
      tableBody.innerHTML = "";

      let rows = allRows.slice();

      if (currentPartyFilter !== "ALL") {
        rows = rows.filter(r => r.partyCategory === currentPartyFilter);
      }

      if (currentSort.key) {
        const dir = currentSort.direction === "asc" ? 1 : -1;
        const key = currentSort.key;

        rows.sort((a, b) => {
          if (key === "name") {
            return a.name.localeCompare(b.name, "lt") * dir;
          }
          if (key === "party") {
            return (a.partyCategory || "").localeCompare(b.partyCategory || "", "lt") * dir;
          }
          const av = a.metrics[key] ?? 0;
          const bv = b.metrics[key] ?? 0;
          const na = Number(av);
          const nb = Number(bv);
          if (Number.isFinite(na) && Number.isFinite(nb)) {
            return (na - nb) * dir;
          }
          return String(av).localeCompare(String(bv), "lt") * dir;
        });
      }

      document.querySelectorAll("th.sortable").forEach(th => {
        th.classList.remove("sorted-asc", "sorted-desc");
        if (th.dataset.sortKey === currentSort.key) {
          th.classList.add(currentSort.direction === "asc" ? "sorted-asc" : "sorted-desc");
        }
      });

      rows.forEach((row, idx) => {
        const tr = document.createElement("tr");

        const tdIndex = document.createElement("td");
        tdIndex.textContent = idx + 1;
        tdIndex.className = "number-cell";
        tr.appendChild(tdIndex);

        const tdName = document.createElement("td");
        tdName.textContent = row.name;
        tdName.className = "name-cell";
        tr.appendChild(tdName);

        const tdParty = document.createElement("td");
        tdParty.className = "party-cell";
        if (row.partyName) {
          const span = document.createElement("span");
          span.className = "party-badge";
          span.textContent = row.partyName;  // pilnas frakcijos / partijos pavadinimas
          span.style.backgroundColor = getPartyColor(row.partyCategory);
          tdParty.appendChild(span);
        }
        tr.appendChild(tdParty);

        allMetricHeaders.forEach(header => {
          const td = document.createElement("td");
          const val = row.metrics[header] ?? 0;
          td.textContent = Number(val || 0);
          td.className = "number-cell";
          tr.appendChild(td);
        });

        tableBody.appendChild(tr);
      });
    }

    partyFilterSelect.addEventListener("change", () => {
      currentPartyFilter = partyFilterSelect.value || "ALL";
      renderTable();
    });

    metricFilterSelect.addEventListener("change", () => {
      const v = metricFilterSelect.value;
      if (!v) {
        currentSort = { key: "name", direction: "asc" };
        renderTable();
        return;
      }

      const map = {
        "most_uz":       { header: keyUz,   dir: "desc" },
        "least_uz":      { header: keyUz,   dir: "asc" },
        "most_pries":    { header: keyPries,dir: "desc" },
        "least_pries":   { header: keyPries,dir: "asc" },
        "most_susilaike":{ header: keySus,  dir: "desc" },
        "least_susilaike":{header: keySus,  dir: "asc" },
        "most_nedalyvavo":{header: keyNed,  dir: "desc" },
        "least_nedalyvavo":{header: keyNed, dir: "asc" },
        "most_reg":      { header: keyReg,  dir: "desc" },
        "least_reg":     { header: keyReg,  dir: "asc" },
        "most_uz_a":     { header: keyUzA,  dir: "desc" },
        "least_uz_a":    { header: keyUzA,  dir: "asc" },
        "most_uz_b":     { header: keyUzB,  dir: "desc" },
        "least_uz_b":    { header: keyUzB,  dir: "asc" }
      };

      const cfg = map[v];
      if (!cfg || !cfg.header) {
        currentSort = { key: "name", direction: "asc" };
      } else {
        currentSort = { key: cfg.header, direction: cfg.dir };
      }
      renderTable();
    });

    (async function init() {
      try {
        statusEl.textContent = "Įkeliami partijų ir balsavimų duomenys...";
        await loadParties();
        await loadStats();
        buildPartyFilterOptions();
        buildTableHead();
        currentSort = { key: "name", direction: "asc" }; // pagal nutylėjimą – abėcėle
        renderTable();
        statusEl.textContent = "Duomenys įkelti. Galite filtruoti ir rūšiuoti lentelę.";
        errorEl.style.display = "none";
      } catch (e) {
        console.error(e);
        statusEl.textContent = "";
        errorEl.textContent = e.message;
        errorEl.style.display = "block";
      }
    })();
  </script>
</body>
</html>
